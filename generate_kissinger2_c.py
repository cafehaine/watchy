#!/usr/bin/env python3

from fnmatch import fnmatch
import glob
import shutil
import textwrap
from typing import Literal
from zipfile import ZipFile

def load_bitmaps(zip_path: str) -> dict[int, bytes]:
    codepoint_bitmap_map = {
    }

    with ZipFile(zip_path, mode="r") as zip_file:
        for file_name in zip_file.namelist():
            if not fnmatch(file_name, "hex/kissinger2fdata*.hex"):
                continue

            with zip_file.open(file_name) as hex_file:
                for line in hex_file:
                    line = line.decode()
                    line = line.strip()
                    if line.startswith(";"):
                        continue
                    if not line:
                        continue
                    codepoint, bitmap = line.split(":", maxsplit=1)
                    codepoint_bitmap_map[int(codepoint, 16)] = bytes.fromhex(bitmap)

    return codepoint_bitmap_map

def print_text(string: str, chars_per_line: str, codepoint_bitmap_map: dict[int, bytes]) -> None:
    if chars_per_line == "auto":
        columns, _ = shutil.get_terminal_size()
        chars_per_line = columns // 17
    else:
        chars_per_line = int(chars_per_line)

    rows = [""] * 16

    def flush_rows():
        nonlocal rows
        for row in rows:
            print(row)
        print()
        rows = [""] * 16

    for index, char in enumerate(string):
        if index % chars_per_line == 0 and index != 0:
            flush_rows()
        codepoint = ord(char)
        bitmap = codepoint_bitmap_map.get(codepoint, codepoint_bitmap_map[ord("□")])
        for y in range(16):
            row_bits = int.from_bytes(bitmap[y*2:y*2+2])
            row = []
            for x in range(15, 0, -1):
                if row_bits>>x&1:
                    row.append("█")
                else:
                    row.append("░")
            rows[y] = rows[y] + " " + "".join(row)

    if rows:
        flush_rows()

def group(L: list[int]):
    """
    Yield ranges of consecutive integers from a sorted list.

    See:
    https://stackoverflow.com/a/2154741
    """
    first = last = L[0]
    for n in L[1:]:
        if n - 1 == last: # Part of the group, bump the end
            last = n
        else: # Not part of the group, yield current group and start a new
            yield first, last
            first = last = n
    yield first, last # Yield the last group


def gencode(output_path: str, codepoint_bitmap_map: dict[int, bytes]) -> None:
    codepoint_groups: list[tuple[int, int]] = list(group(list(sorted(codepoint_bitmap_map.keys()))))

    with open(output_path, "w") as source_code_file:
        # TODO split array into multiple lines to help text editors load the file :)
        bitmaps = b"".join(codepoint_bitmap_map.values())
        bitmaps_c_array = "{" + ",".join([str(int(byte)) for byte in bitmaps]) + "}"

        source_code_file.write(textwrap.dedent(f"""\
            /**********************************************************************/
            /* This file was automatically generated by generate_kissinger2_c.py. */
            /* Do *NOT* edit this file manually, as any changes will be lost.     */
            /**********************************************************************/

            #include "kissinger2.h"

            uint8_t bitmaps[] = {bitmaps_c_array};

            struct GlyphBitmap ksg2_char_bitmap(char *glyph_start) {{
            uint32_t codepoint = 9633;
            uint8_t glyph_length = 1;
    
            if ((glyph_start[0] & 0b10000000u) == 0b00000000u) {{
                // Single byte glyph
                codepoint = (uint8_t)glyph_start[0];
                glyph_length = 1;
            }} else if ((glyph_start[0] & 0b11100000u) == 0b11000000u && (glyph_start[1] & 0b11000000u) == 0b10000000u) {{
                // Two bytes glyph
                codepoint = (glyph_start[0] & 0b00011111u)<<6 | (glyph_start[1] & 0b00111111u);
                glyph_length = 2;
            }} else if ((glyph_start[0] & 0b11110000u) == 0b11100000u && (glyph_start[1] & 0b11000000u) == 0b10000000u && (glyph_start[2] & 0b11000000u) == 0b10000000u) {{
                // Three bytes glyph
                codepoint = (glyph_start[0] & 0b00001111u)<<12 | (glyph_start[1] & 0b00111111u)<<6 | (glyph_start[2] & 0b00111111u);
                glyph_length = 3;
            }} else if ((glyph_start[0] & 0b11111000u) == 0b11110000u && (glyph_start[1] & 0b11000000u) == 0b10000000u && (glyph_start[2] & 0b11000000u) == 0b10000000u && (glyph_start[3] & 0b11000000u) == 0b10000000u) {{
                // Four bytes glyph
                codepoint = (glyph_start[0] & 0b00000111u)<<18 | (glyph_start[1] & 0b00111111u)<<12 | (glyph_start[2] & 0b00111111u)<<6 | (glyph_start[3] & 0b00111111u);
                glyph_length = 4;
            }}
            switch (codepoint) {{
        """))

        array_index = 0
        for start, end in group(list(sorted(codepoint_bitmap_map.keys()))):
            if start == end:
                source_code_file.write(textwrap.dedent(f"""\
                    case {start}:
                    return (struct GlyphBitmap){{bitmaps + {array_index * 32}, glyph_length}};
                """))
            else:
                source_code_file.write(textwrap.dedent(f"""\
                    case {start} ... {end}:
                    return (struct GlyphBitmap){{bitmaps + {array_index * 32} + (codepoint - {start}) * 32, glyph_length}};
                """))
            array_index += end - start + 1

        source_code_file.write("}\n}\n")

if __name__ == "__main__":
    from argparse import ArgumentParser
    parser = ArgumentParser()
    parser.add_argument("--kissinger-zip-path", "-k", default="build/kissinger2dev4.zip")
    subparsers = parser.add_subparsers(title="mode", required=True)

    print_parser = subparsers.add_parser("print", help="Print some text")
    print_parser.set_defaults(mode="print")
    print_parser.add_argument("--chars-per-line", "-c", default="auto")
    print_parser.add_argument("text", nargs="+")

    gencode_parser = subparsers.add_parser("gencode", help="Generate kissinger2.c")
    gencode_parser.set_defaults(mode="gencode")
    gencode_parser.add_argument("--output", "-o", default="src/kissinger2.c")

    args = parser.parse_args()

    codepoint_bitmap_map = load_bitmaps(args.kissinger_zip_path)

    if args.mode == "print":
        print_text(" ".join(args.text), args.chars_per_line, codepoint_bitmap_map)
    elif args.mode == "gencode":
        gencode(args.output, codepoint_bitmap_map)
